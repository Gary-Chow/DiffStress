"""
Applications for RS package
"""
## Global dependents
import os, glob, shutil
from tempfile import mkstemp, mkdtemp
from tempfile import NamedTemporaryFile as NTF
from tempfile import TemporaryFile as TF
import cPickle as pickle

def find_tmp(ir=False):
    """
    Find the relevant temp folder
    in compliance with the CTCMS cluster policy,
    The rule is if there's /data/
    create files there and run vpsc there.

    Arguments
    ---------
    ir = False

    Return
    ------
    _tmp_
    """
    ## Find /data/
    if os.path.isdir('/data/'): _tmp_='/data/ynj/'
    else: _tmp_='/tmp/ynj/'

    if not(os.path.isdir(_tmp_)):
        os.mkdir(_tmp_)
    if ir: _tmp_ = mkdtemp(dir=_tmp_, prefix='MonteCarlo_rs_grid_')
    return _tmp_

_tmp_ = find_tmp()

def plot(fn,irst=False):
    """
    fn name of output file generated by this module
    irst: if True, return the resulting variables without plotting
    """
    import numpy as np
    dicts=read_args(fn)
    sigmas=dicts['sigmas']
    ss    =dicts['ss']
    nhead=int(open(fn,'r').readline().split('\n')[0].split(':')[1])
    dat=np.loadtxt(fn,skiprows=nhead).T
    if irst: return dat,dicts

    ls=['-+','-s','-o','-d','-t']
    import matplotlib.pyplot as plt
    from MP.lib import mpl_lib,axes_label

    fancy_legend = mpl_lib.fancy_legend
    wide_fig     = mpl_lib.wide_fig
    deco         = axes_label.__deco__
    fig          = wide_fig(nw=1,nh=1);
    ax1          = fig.axes[0]

    ymax=max(dat[1:1+len(sigmas)].flatten())

    for i in range(len(sigmas)):
        ax1.plot(dat[0],dat[1+i],ls[i],mfc='None',color='k',label='%6.0e'%sigmas[i])
        #ax1.plot(dat[0][::ss],np.zeros((len(dat[0][::ss]),)),'o',mec='k',mfc='None',ms=8)
        x=dat[0][::ss]
        for j in range(len(x)):
            ax1.plot([x[j],x[j]],[0,ymax],'--',color='gray',alpha=0.2)

    ## standard deviation
    fig = wide_fig(nw=1,nh=1);
    ax1 = fig.axes[0]
    for i in range(len(sigmas)):
        ax1.errorbar(dat[0],dat[1+i],yerr=dat[1+i+len(sigmas)], label='%6.0e'%sigmas[i])

def write_args(fn,**kwargs):
    """
    Write keyword arguements to the file
    """
    fn.write('nhead including this line: %i\n'%(len(kwargs)+4))
    for i in range(80): fn.write('-')
    fn.write('\n')

    for key in kwargs:
        fn.write('%12s  =  %12s \n'%(key, kwargs[key]))
    for i in range(80): fn.write('-')
    fn.write('\n')

def read_args(fn):
    """
    Read arguments written by write_args
    Make it as dictionary and return
    """
    f     = open(fn,'r')
    nline = int(f.readline().split('\n')[0].split(':')[1])
    f.close()
    f     = open(fn,'r')
    lines = f.readlines()[2:nline-2]
    dicts  = {}
    for i in range(len(lines)):
        key,val = lines[i].split('=')
        try:
            val = float(val.split('\n')[0])
        except:
            try: val = str2list(val.split('\n')[0])
            except:
                try:
                    val =str2bool(val.split('\n')[0].strip())
                except:
                    raise IOError, 'nothing worked.'

        dicts[key.strip()] = val
    return dicts

def str2list(string):
    """
    Convert string to list
    """
    return map(float,string.split('[')[1].split(']')[0].split(','))

def str2bool(string):
    """
    Convert string to boolean
    """
    if string=='True': return True
    if string=='False': return False


def find_args(fn,kw):
    """Given the keyword, find the corresponding argument"""


## below is for command line run
## which is also used in rs_grid.py
if __name__=='__main__':
    from RS import mst_ex
    ## List of default arguments
    ## sigmas       = [1e-5, 2e-5, 5e-5, 1e-4]

    ss           = 3         ## DEC acquisition frequency every 'ss' plastic levels
    bounds       = [0.,0.5]  ## sin2psi min and max
    nbins        = 10        ## Psi Tilting number
    iwgt         = True      ## Whether or not waight in stress calculation
    nsample      = 4         ## Number of sampling for a statistical ensemble
    intp_opt     = 0         ## Interpolation function
    iplot        = False     ##
    DEC_freq_sym = True      ## Draw symbols at which DEC is acquired.
    NCPU         = 0         ## Number of NCPU passed to the run.


    ## additional diffraction conditions that are associated
    ## with the uncertainty is peak position (d-spacing)
    bragg        = 78.2      ## Bragg angle
    #              78.2  -      Fe {211} plane using Cr K-alpha
    ird          = 0.182     ## intensity of random distribution
    #              0.182        {211} using window of 10
    #              0.0457       {211} using window of  5
    nfrq         = None

    import argparse
    from os import getcwd, sep

    ## temp working path
    path_work = find_tmp(ir=True)
    path_home = os.getcwd()


    ## output file name
    handler, abs_path_name = mkstemp(prefix='rs_par_',suffix='.dat',dir=path_home)
    ##

    parser = argparse.ArgumentParser()
    parser.add_argument('--sigmas',   type=str,help='a list of standard deviation for eps(hkl) noise as in counting stats error')
    parser.add_argument('--ss',       type=int,help='inverse frequency in DEC',default=ss)
    parser.add_argument('--bounds',   type=str,help='sin2psi bounds',default=str(bounds))
    parser.add_argument('--nbins',    type=int,help='Number of tilting angles (psi)',default=nbins)
    parser.add_argument('--nsample',  type=int,help='Number of ensembles',default=nsample)
    parser.add_argument('--ncpu',     type=int,help='Number of CPUS for multiprocessing.pool',default=NCPU)
    parser.add_argument('--filename', type=str,help='Data file name', default=abs_path_name)
    parser.add_argument('--bragg'   , type=float,help='Bragg angle', default=bragg)
    parser.add_argument('--ird'   ,   type=float,help='Intensity of random distribution', default=ird)
    parser.add_argument('--nfrq'  ,   type=int,help='Number of frequency in I/O', default=nfrq)
    parser.add_argument('-p', action='store_true',default=False,dest='iplot',help='Switch for plot')

    args     = parser.parse_args()
    sigmas   = args.sigmas
    ss       = args.ss
    bounds   = args.bounds
    nbins    = args.nbins
    nsample  = args.nsample
    NCPU     = args.ncpu
    filename = args.filename
    bragg    = args.bragg
    ird      = args.ird
    iplot    = args.iplot
    try:
        nfrq     = int(args.nfrq)
    except:
        nfrq     = args.nfrq
    else:
        nfrq     = args.nfrq

    if filename!=abs_path_name.split(os.sep)[-1]:
        os.remove(abs_path_name)

    ## abs_path_name = args.filename
    sigmas=map(float,sigmas.split())
    bounds=map(float,bounds.split())
    fout  =open(filename,'w')
    fout_f=open(filename.split('.dat')[0]+'.pck','wb')

    ## move necessary files to path_work
    data_necessary = glob.glob('*.out') + glob.glob('*.OUT')
    for i in xrange(len(data_necessary)):
        shutil.copy(data_necessary[i], path_work)

    ## change to path_work
    os.chdir(path_work)

    x,M,s,H,B,flow_row = mst_ex.influence_of_cnts_stats(
        sigmas,bounds,ss,nbins,iwgt,nsample,intp_opt,
        iplot,bragg,ird,nfrq,DEC_freq_sym,NCPU)
    ## pickling flow_row
    pickle.dump(flow_row,fout_f)
    fout_f.close()

    os.chdir(path_home) ## getting back to path_home

    write_args(fout,sigmas=sigmas,ss=ss,bounds=bounds,
               nbins=nbins,iwgt=iwgt,bragg=bragg,ird=ird,
               nfrq=nfrq,
               nsample=nsample,intp_opt=intp_opt,iplot=iplot,
               DEC_freq_sym=DEC_freq_sym,NCPU=NCPU,fout_f=fout_f.name)

    fout.write('%11s '%'evm')
    for i in range(len(sigmas)): fout.write('%11.4e '%sigmas[i])
    for i in range(len(sigmas)): fout.write('%8istd '%(i+1))

    fout.write('\n')
    for i in range(len(x)):
        fout.write('%11.4e '%x[i])
        for j in range(len(sigmas)):
            fout.write('%11.4e '%M[j][i])
        for j in range(len(sigmas)):
            fout.write('%11.4e '%s[j][i])
        fout.write('\n')

    fout.close()
    print '%s has been created.'%filename

    ## histogram data
    import numpy as np
    print 'save histogram in:', os.getcwd()
    np.save('hist',H)
    np.save('bins',B)
